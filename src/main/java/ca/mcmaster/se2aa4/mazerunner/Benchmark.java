package ca.mcmaster.se2aa4.mazerunner;

import ca.mcmaster.se2aa4.mazerunner.MazeStructure.Path;

import java.math.BigDecimal;
import java.math.MathContext;
import java.math.RoundingMode;

public class Benchmark {
    private long start;
    private long elapsed;
    private boolean timerOn;

    public Benchmark() {
        this.timerOn = false;
    }

    /**
     * Starts the timer if timer is currently off
     */
    public void startTimer() {
        if (!this.timerOn) {
            this.start = System.nanoTime();
            this.timerOn = true;
        } else {
            System.out.println("Need to end timer first");
        }
    }

    /**
     * Ends the timer if timer is currently on
     */
    public void endTimer() {
        if (this.timerOn) {
            long end = System.nanoTime();
            this.timerOn = false;
            this.elapsed = end - this.start;
        } else {
            System.out.println("Need to start timer first");
        }
    }

    /**
     * @return elapsed time from most recent timing
     */
    public double getElapsedTime() {
        // Convert and round
        if (!this.timerOn) {
            return convertNanoMilli(this.elapsed);
        } else {
            System.out.println("No start or end time!");
            return -1.0;
        }
    }

    /**
     * Converts nanoseconds to milliseconds
     *
     * @param nano time in nanoseconds
     * @return time in milliseconds
     */
    private double convertNanoMilli(long nano) {
        BigDecimal milli = new BigDecimal(nano).divide(new BigDecimal(1000000));
        return adjustSigFigs(milli.doubleValue());
    }

    /**
     * Adjusts given value to 2 sigfigs
     *
     * @param value Number to be adjusted
     * @return Number in 2 sigfigs
     */
    private double adjustSigFigs(double value) {
        if (value == 0) { return 0; }
        return new BigDecimal(value, new MathContext(2, RoundingMode.HALF_UP)).doubleValue();
    }

    /**
     * Calculates the speedup. Speedup = |baselinePath| / |methodPath|
     *
     * @param baselinePath path generated by algorithm specified by the baseline option
     * @param methodPath path generated by algorithm specified by the method option
     * @return speedup of baselinePath relative to methodPath
     */
    public double calcSpeedUp(Path baselinePath, Path methodPath) {
        int baselinePathLen = baselinePath.getCanonicalForm().replace(" ", "").length();
        int methodPathLen = methodPath.getCanonicalForm().replace(" ", "").length();
        return adjustSigFigs((double) baselinePathLen / methodPathLen);
    }
}
